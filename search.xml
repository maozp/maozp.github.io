<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[restful设计指南]]></title>
    <url>%2F2018%2F12%2F24%2F%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[一、协议API与用户的通信协议，总是使用HTTPs协议。 二、域名应该尽量将API部署在专用域名之下。 https://api.example.com如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 https://example.org/api/ 三、版本（Versioning）应该将API的版本号放入URL。https://api.example.com/v1/另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 四、路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees 五、HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。12345GET（SELECT）：从服务器取出资源（一项或多项）。POST（CREATE）：在服务器新建一个资源。PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。DELETE（DELETE）：从服务器删除资源。 还有两个不常用的HTTP动词。 HEAD：获取资源的元数据。OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。下面是一些例子。12345678GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。12345?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。123456789101112200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见这里。 八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: &quot;Invalid API key&quot;&#125; 九、返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。123456GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档 十、Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 123456&#123;&quot;link&quot;: &#123; &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, &quot;title&quot;: &quot;List of zoos&quot;, &quot;type&quot;: &quot;application/vnd.yourformat+json&quot;&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 12345&#123; &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;, // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 1234&#123; &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;&#125; 上面代码表示，服务器给出了提示信息，以及文档的网址。 十一、其他（1）API的身份认证应该使用OAuth 2.0框架。 （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 本文引用自阮一峰的网络日志,感谢作者的分享。]]></content>
      <categories>
        <category>restful</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基础学习笔记]]></title>
    <url>%2F2018%2F12%2F24%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[启动/关闭mysql服务启动mysql服务：net start mysql停止mysql服务：net stop mysql（所有windows的服务都可以通过这两个命令实现） 错误处理：1.net start mysql服务正在启动或停止中，请稍候片刻后再试一次，解决办法：任务管理器-进程-结束mysql相关的进程，重新net start mysql即可。2.安装完mysql没有my.ini文件解决办法：将my-default.ini文件重命名为my.ini3.创建数据库，报1044解决办法：1.关闭服务 2.在mysqld语句下，增加 skip_grant_tables mysql登录与退出版本号:mysql -v退出: exit;quit;\q; 打开数据库testmysql -uroot -proot test MYSQL语法规范：1.关键字和函数名称全部大写2.数据库名称、表名称、字段名称全部小写3.SQL语句必须以分号结尾 操作MYSQL语据库创建数据库语法：CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name[DEFAULT] CHARACTER SET [=] charset_name{} 必选项| 选择，两项或三项中选择[] 有或者没有，称为可选项例：CREATE DATABASE t1; 创建数据库t1CREATE DATABASE IF NOT EXISTS t1; 忽略存在错误查看当前服务器下的数据表列表:SHOW {DATABASE | SCHEMAS}[LIKE ‘pattern’ | WHERE expr]例：SHOW WARNINGS; 查看警告CREATE DATABASE IF NOT EXISTS t2 CHARACTER SET utf8; //创建utf8编码的数据库修改数据库ALTER {DATABASE | SCHEMA} [db_name];[DELETE] CHARACTER SET [=] charset_name;例：ALERT DATABASE t2 CHARACTER SET = gbk; //修改t2表字符编码SHOW CREATE DATABASE t2; //查看t2表创建信息删除数据库DROP {DATABASE | SCHEMA} [IF EXISTS] db_name例：DROP DATABASE t1; //删除数据库表1SHOW DATABASES; //查看数据库列表，已成功删除DROP DATABASE IF EXISTS t1; //再次删除 不显示错误提示SHOW WARNINGS; //显示错误提示总结：MySQL默认的端口号是：3306MySQL中的超级账号是：root创建数据库：CREATE DATABASE修改数据库：ALTER DATABASE删除数据库：DROP DATABASE 数据类型与数据表操作数据类型：整数型浮点型日期时间型字符型CHARVARCHAR数据表(表)打开数据库SHOW DATABASES; //有哪些数据库USE test; //打开test表SELECT DATABASE(); //当前打开的数据库创建数据表CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type,…(最后一个不加逗号))例：CREATE TABLE tb1(username VARCHAR(32), //用户名字符型，有字符长度限制使用VARCHAR(32)age TINYINT UNSIGNED, //年龄整型，有长度限制，且不能为负salary FLOAT(8,2) UNSIGNED //薪水整型，有长度限制，且不能为负);查看数据表SHOW TABLES [FROM db_name] //db_name数据库名[LIKE ‘pattern’ | WHERE expr]查看数据表结构SHOW COLUMNS FROM tbl_name插入记录INSERT [INTO] tb_name [(col_name,…)] VALUES(val,…)例：INSERT tb1 VALUES(‘Tom’, 24, 1200.34); //正确插入记录INSERT tb1 VALUES(‘Tammy’, 26); //报错,语法错误。INSERT tb1(username,salary) VALUES(‘John’, 1200.90); //正确记录查找SELECT expr,… FROM tb1_name //tb1_name:表名例：SELECT FROM tb1; // 表示全部的字段记录完善：空值与非空：NULL 字段值可以为空；NOT NULL 字段值禁止为空；例：创建数据表CREATE TABLE tb2(username VARCHAR(20) NOT NULL,age TINYINT UNSIGNED NULL,salary FLOAT(8,2) UNSIGNED NOT NULL);查看数据表SHOW TABLES tb2;插入记录INSERT tb2 VALUES(‘Tom’,NULL); //报错INSERT tb2 VALUES(‘Tom’,NULL,23000.00); //正确插入记录选择记录SELECT FROM tb2; //正确查出结果记录唯一性 AUTO_INCREMENT自动编号，且必须与主键组合使用（但是主键不一定非要与AUTO_INCREMENT一起使用）默认情况下，起始值为1，每次的增量为1这个字段必须是整型或浮点型，且起始必须为0例：CREATE TABLE tb3(id SMALLINT UNSIGNED AUTO_INCREMENT,username VARCHAR(30) NOT NULL);//报错：… it must be defined as a key 必须定义为主键主键 PRIMARY KEY主键约束每张数据表只能存在一个主键主键保证记录的唯一性主键自动为NOT NULL例：CREATE TABLE tb3(id SMALLINT NOSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(30) NOT NULL); //正确创建数据表tb3INSERT tb3 VALUES(‘Tammy’);//正确INSERT tb3 VALUES(‘Tom’);//正确SELECT FROM tb3;//查找记录创建一张表只有主键，没有AUTO_INCREMENT可不可以CREATE TABLE tb4(id SMALLINT NOSIGNED PRIMARY KEY,username VARCHAR(30) NOT NULL); //创建成功INSERT tb4 VALUES(4,’Tom’);//插入记录INSERT tb4 VALUES(0,’Tommy’); //插入记录SELECT FROM tb4; //查找记录UNIQUE KEY唯一约束唯一约束可以保证记录的唯一性唯一约束的字段可以为空值(NULL)每张数据表可以存在多个唯一约束例：CREATE TABLE tb5(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(30) NOT NULL UNIQUE KEY,age TINYINT UNSIGNED);INSERT tb5(username, age) VALUES(‘Tammy’, 24); //正确INSERT tb5(username, age) VALUES(‘Tom’, NULL); //正确INSERT tb5(username, age) VALUES(‘Tom’, 26); //报错：Duplicate entry ‘Tom’ for key ‘username’ ,username 唯一性默认值 DEFAULT插入记录时，如果没有时确为字段赋值，则自动赋予默认值例：CREATE TABLE tb6(id SMALLINT AUTO_INCREMENT PRIMARY KEY,username VARCHAR(30) NOT NULL UNIQUE KEY,sex ENUM(‘1’,’2’,’3’) DEFAULT ‘3’);SHOW COLUMNS FROM tb6;INSERT tb6(username) VALUES(‘Tammy’); //默认赋值sex—约束外键约束FOREIGN KEY保持数据一致性，完整性实现一对一或一对多的关系(关系型数据库)要求：1.父表与子表必须使用相同的存储引擎，而且禁止使用临时表；子表:具有外键列的表称为子表父表:子表参照的表称为父表2.数据表的存储引擎只能为InnoDB;3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。例：USE test;CREATE TABL provinces(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,name VARCHAR(20) NOT NULL);SHOW CREATE TABLE provinces; //确定表存储引擎是InnoDBCREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(10) NOT NULL,pid BIGINT, //外键列数据类型与provinces中id的参数列数据类型不同FOREIGN KEY (pid) REFERENCES provinces (id)); //报错,未创建成功CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(10) NOT NULL,pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES provinces (id)); //正确解析：users子表provinces父表FOREIGN KEY 有外键的表称为子表users外键表provinces参照表id参数列 必须创建索引 PRIMARY KEY自动创建索引pid外键列 必须创建索引SHOW INDEXES FROM provinces; //查看索引SHOW INDEXES FROM provinces\G; //查看索引回车外键约束的参照操作1.CASCADE: 从父表删除或更新且自动删除或更新子表中匹配的行2.SET NULL：从父表删除或更新行，并设置子表中的外键列3.RESTRICT:拒绝对父表的删除或更新操作4.NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同CREATE TABLE prov(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,name VARCHAR(10));CREATE TABLE city(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30),pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES prov(id) ON DELETE CASCADE);//ON DELETE CASCADE 父表删除一条记录，子表中参数列所在的行也会被删除插入记录，必须先在父表中插入然后才能在子表中插入，原因子表参照父表中的信息父表中插入记录：INSERT provinces(name) VALUES(‘a’);INSERT provinces(name) VALUES(‘b’);INSERT provinces(name) VALUES(‘c’);查看记录：SELECT FROM provinces;子表中插入记录：INSERT users(username,pid) VALUES(‘Tom’,3);INSERT users(username,pid) VALUES(‘Tammy’, 2);父表中删除一条记录DELETE FROM provinces WHERE id =1;查看记录：SELECT FROM provinces; //删除成功SELECT FROM user1; //子表中跟父表相关的记录也删除了修改数据表添加单列ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST | AFTER col_name]例：SHOW COLUMNS FROM city; //查看数据表结构ALTER TABLE city ADD code TINYINT UNSIGNED NOT NULL DEFAULT ‘0000’; //添加code列ALTER TABLE city ADD email VARCHAR(60) NOT NULL; //添加email列SHOW COLUMNS FROM city; //查看数据表结构ALTER TABLE city ADD tel TINYINT NOT NULL AFTER pid; //在pid列之后删除列ALTER TABLE tbl_name DROP [COLUMN] col_name例ALTER TABLE ctiy DROP tel; //删除tel列SHOW COLUMNS FROM city; //查看删除后的表结构添加主键约束ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] PRIMARY KEY index_type例:创建user2数据表CREATE TABLE user2(username VARCHAR(20) NOT NULL,pid SMALLINT(5) UNSIGNED DEFAULT NULL);ALTER TABLE user2 ADD id SMALLINT UNSIGNED; //成功添加ALTER TABLE user2 ADD CONSTRAINT PK_users2_id PRIMARY KEY (id); //成功添加主键约束添加唯一约束ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type](index_col_name,…)例：设置唯一约束ALTER TABLE users2 ADD UNIQUE (username); //设置username为唯一约束添加外键约束ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]]FOREIGN KEY [index_name] (index_col_name,…)reference_definition例：添加外键约束ALTER TABLE users ADD FOREIGN KEY (pid) REFERENCES provinces (id); //设置外键约束SHOW CREATE TABLE users2;添加/删除默认约束ALTER TABLE tbl_name ALTER [COLUMN] col_mame{SET DEFAULT literal | DROP DEFAULT}例：ALTER TABLE users2 ADD email VARCHAR(60) NOT NULL DEFAULT 1; //添加数据列设置默认值为1SHOW COLUMNS FROM users2;//查看数据表结构ALTER TABLE users2 ALTER email DROP DEFAULT; //删除默认约束ALTER TABLE users2 ALTER email SET DEFAULT 12; //添加默认值为12删除主键约束ALTER TABLE tbl_name DROP PRIMARY KEY;//没有指定字段？原因：一个表只有一个主键约束例：SHOW COLUMNS FROM users2;//查看主键约束ALTER TABLE users2 DROP PRIMARY KEY; //删除主键约束 UNIQUE删除唯一约束ALTER TABLE tbl_name DROP {INDEX|KEY} index_name//为什么有{INDEX|KEY}？原因：一个表可以有多个唯一约束例：SHOW INDEXES FROM users2;//查看唯一约束ALTER TABLE users2 DROP INDEX username; //删除唯一约束，并不是删除字段删除外键约束ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol例：SHOW CREATE TABLE users2; //查看外键约束,系统赋予的’users2_ibfk_1’ALTER TABLE users2 DROP FOREIGN KEY users2_ibfk_1; //删除外键约束SHOW CREATE TABLE users2;//查看外键约束,已删除外键ALTER TABLE users2 DROP INDEX pid//字段上的索引依然存在，删除索引SHOW CREATE TABLE users2;//查看数据表,已删除索引修改列定义：数据列的名字没有问题，位置或是类型有问题ALTER TABLE tbl_name MODIFY [COLUMN] col_namecolumn_definition [FIRST | AFTER col_name]例：修改列位置ALTER TABLE users2 MODIFY id SMALLINT UNSIGNED FIRST; //将id改到数据表第一位SHOW COLUMNS FROM users2; //查看修改结果,id字段排在第一位ALTER TABLE users2 MODIFY id TINYINT UNSIGNED; //修改id字段类型SHOW COLUMNS FROM users2; //注意修改类型会导致数据出问题修改列名称ALERT TABLE tbl_name CHANGE [COLUMN] old_col_namenew_col_name column_definition [FIRST|AFTER col_name]例：修改列名称 pid类型修改-tinyint 名称也修改p_idALTER TABLE users2 CHANGE pid p_id TINYINT UNSIGNED NOT NULL;//列名称修改了，列定义也修改了。//功能比modify更强大修改数据表名称：不建议更改，会导致引用该表的视图出错方法1：ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name方法2：RENAME TABLE tbl_name TO new_tbl_name[,tbl_name2 TO new_tbl_name2] …例：users2改成test;ALTER TABLE users2 RENAME TO test; //修改表名称SHOW TABLES;//查看所有表，已更改总结：约束：功能：NOT NULL(非空约束)PRIMARY KEY(主键约束)UNIQUE KEY(唯一约束)DEFAULT(默认约束)FOREIGN KEY(外键约束)数据列的数目：列级约束表级约束修改数据表：针对字段的操作：添加、删除字段，修改列定义，修改列名称等针对约束的操作：添加、删除各种约束针对数据表的操作：数据表更名(两种方式)记录的操作插入记录1：INSERT [INTO] tbl_name [(col_name,…)] {VALUES|VALUE}({expr | DEFAULT},…),(…),…例：CREATE TABLE user(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(20) NOT NULL,password VARCHAR(32) NOT NULL,age TINYINT UNSIGNED DEFAULT 18,sex BOOLEAN);INSERT user VALUES(NULL,’A’, ‘123’,24, 1); //NULL:AUTO_INCREMENTINSERT user VALUES(DEFAULT,’B’,’123’,24, 1); //DEFAULT:AUTO_INCREMENTINSERT user VALUES(DEFAULT,’C’,’123’,24); //报错，缺少字段INSERT user VALUES(DEFAULT,’D’,’123’,DEFAULT, 1); //age字段记录DEFAULT默认值INSERT user VALUES(DEFAULT,’E’,’123’,46-2, 1); //字段可以是表达式，也可以是函数INSERT user VALUES(DEFAULT,’Tammy’,’abc’,28,2),(NUll,’Tommy’,md5(‘abc’),30,1); //插入多条插入记录2:与上一种的区别在于，此方法可以使用子查询(SubQuery),一次只能插入一条INSERT [INTO] tbl_name SET col_name={expr | DEFAULT},…例：INSERT user SET username=’Ben’,password=’456’;更新记录(单表更新)UPDATEUPDATE [LOW_PRIORITY] [IGNORE] table_reference SETcol_name={expr1|DEFAULT} [,col_name2={expr2|DEFAULT}]…[WHERE where_condition]例：更新操作UPDATE user SET age = age +5; //省略条件，表中所有记录的年龄加5UPDATE user SET age = age - id,sex = 0; //多条记录修改UPDATA user SET age = age + 10 WHERE id % 2 = 0;//加限制条件，偶数列年龄在原先基础上加10删除操作(单表删除)DELETE删除后，再次插入记录id号在原来记录上+1DELETE FROM tbl_name [WHERE where_condition]例：DELETE FROM user WHERE id = 6; //删除第六条记录查询记录SELECT （占数据表操作的80%）SELECT select_expr[,select_expr,…][FROM table_references[WHERE where_codition][GROUP BY {col_name | position} [ASC | DESC],…][HAVING where_condition][ORDER BY {col_name | expr | position} [ASC | DESC],…][LIMIT {[offset,] row_count | row_count OFFSET offset}]]例：SELECT VERSION();SELECT NOW();SELECT 35;SELECT id,username FROM user; //从数据表中选取id,username两列，返回的结果中只包含这两列SELECT username,id FROM user; //返回的结果中username列排在前面SELECT FROM user;//表示所有列SELECT user.id,user.sex FROM user; //列名称前跟上表名，用于查询多个数据表操作查询表达式select_expr每一个表达式表示想要的一列，必须有至少一个多个列之间以英文逗号分隔星号()表示所有列。tbl_name.可以表示命名表的所有列查询表达式可以使用[ AS ] alias_name为其赋予别名别名可用于GROUP BY,ORDER BY或HAVING子句例：所谓别名SELECT id AS userID,username AS userName FROM user; //AS关键字强烈建议写上条件表达式WHERE对记录进行过虑，如果没有指定WHERE子句，则显示所有记录在WHERE表达式中，可以使用MySQL支持的函数或运算符查询结果分组GROUP BY[GROUP BY {col_name | position} [ASC | DESC],…]ASC 默认升序DESC 降序例：SELECT sex FROM user GROUP BY sex; //以性别为组查询SELECT sex FROM user GROUP BY 1; //1表示SELECT中出现的第一个字段名称分组条件HAVING[HAVING where_condition]例：SELECT sex FROM user GROUP BY 1 HAVING age&gt;20; //出错，HAVING后面的字段必须出现在SELECT中SELECT sex,age FROM user GROUP BY 1 HAVING age&gt;20;//正确，HAVING后面跟聚合函数(max最大值,min最小值,平均值,计数,绝对值,求和等等)对查询结果进行排序ORDER BY[ORDER BY {col_name | expr | position} [ASC | DESC],…]例：SELECT FROM user ORDER BY id DESC; //按照id降序排列SELECT FROM user ORDER BY age, id DESC; //按照 age升序，id降序 排序限制查询结果返回的数量LIMIT分页效果[LIMIT {[offset,] row_count | row_count OFFSET offset}]例：SELECT FROM user LIMIT 2; //返回两条记录SELECT FROM user LIMIT 3,2; //从0计数，第三条起两条记录SELECT FROOM user LIMIT 2,2; //第2条开始2条记录SELECT * FROM user ORDER BY id DESC LIMIT 2,2; // id DESC不起作用插入记录2与SELECT运用：将查询结果插入到另一表中：例:CREATE TABLE tb1(id TINYINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(32));INSERT tb1(username) SELECT username FROM user WHERE age&gt;=28;//将user表中年龄大于28的usernamed插入到tb1表中 总结： 记录操作最重要的SELECT操作子查询定义和条件：子查询(Subquery)是指出现在其他SQL语句内的SELECT子句。查询:这里的查询指所有SQL语句返回的结果例如SELECT FROM t1 WHERE col1 = (SELECT col2 FROM t2);其中SELECT FROM t1,称为Outer Query / Outer StatementSELECT col2 FROM t2,称为SubQuery子查询指嵌套在查询内部，且必须始终出现在圆括号内。子查询可以包含多个关键字或条件如DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等子查询的外层查询可是SELECT、INSERT、UPDATE、SET或DO。子查询结果使用比校运算符的子查询=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt;语法结构operand comparison_operator subquery例：查询商品平均价格SELECT AVG(goods_price) FROM test_goods;//AVG求平均值函数SELECT ROUND(AVG(goods_price),3) FROM test_goods;//ROUND四舍五入保留3位小数,结果为6326.500//22个商品中哪些大于平均值SELECT goods_id,goods_name,goods_price FROM test_goods WHERE goods_price &gt;= 6326.500;//6326.500上一个查询的结果使用子查询的写法：SELECT goods_id,goods_name,goods_price FROM test_goods WHERE goods_price &gt;= (SELECT ROUND(AVG(goods_price),3) FROM test_goods);用ANY、SOME或ALL修饰的比较运算符operand comparison_operator ANY(subquery)operand comparison_operator SOME(subquery)operand comparison_operator ALL(subquery)如果不加修改，报错：Subquery returns more than 1 row;ANY、SOME、ALL关键字返回的结果： 、&gt;=: ANY:最小值 SOME:最小值 ALL:最大值&lt;、&lt;=: ANY:最大值 SOME:最大值 ALL:最小值=: ANY:任意值 SOME:任意值 ALL:无&lt;&gt;、!=: ANY:无 SOME:无 ALL:任意值 查询超级本类型商品的价格SELECT goods_price FROM test_goods WHERE goods_cate = ‘超级本’;SELECT * FROM test_goods WHERE goods_price &gt;= SOME(SELECT goods_price FROM test_goods WHERE goods_cate = ‘超级本’); 使用[NOT] IN 子查询语法结构operand comparison_operator [NOT] IN (Subquery)=ANY运算符与IN等效!=ALL或&lt;&gt;ALL运算符与NOT IN等效使用[NOT] EXISTS的子查询如果子查询返回任何行，EXISTS将返回TRUE；否则为FALSE。例：CREATE TABLES IF NOT EXISTS test_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40) NOT NULL);//记录来源：test_goods中的分类SELECT goods_cate FROM test_goods GROUP BY goods_cate;INSERT … SELECT将查询结果写入数据表INERT [INTO] tbl_name [(col_name,…)]SELECT…例：将查询结果写入到新的数据表中INSERT test_goods_cates(cate_name) SELECT goods_cate FROM test_goods GROUP BY goods_cate;多表更新UPDATE table_referencesSET col_name1={expr1|DEFAULT}[,col_name2={expr2|DEFAULT}] …[WHERE where_condition]例：更新test_goods中的goods_cate字段UPDATE test_goods INNER JOIN test_goods_cates ON goods_cate = cate_nameSET goods_cate = cate_id;SELECT * FROM test_goods\G;//可以看到test_goods中的goods_cate全部更新成test_goods_cates中的cata_id值CREATE…SELECT创建数据表同时将查询结果写入到数据表CREATE TABLE [IF NOT EXISTS] tbl_name[(create_definition),…]select_statement例：CREATE TABLE test_goods_brands(brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brnd_name VARCHAR(40) NOT NULL)SELECT brand_name FROM test_goods GROUP BY brand_name;SHOW COLUMNS FROM test_goods;//结果显示test_goods表中数据更新了但是结构未更新ALTER TABLE test_goodsCHANGE goods_cate cate_id SMALLINT UNSIGNED NOT NULL,CHANGE brand_name brand_id SMALLINT UNSIGNED NOT NULL;//将test_goods表中的结构更新成新创建的表中的结构。事实外键FROM子句中的子查询语法结构SELECT…FROM (Subquery) [AS] name …说明：名称必选项，且子查询的列名称必须唯一连接MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作语法结构：table_references{[INNER|CROSS] JOIN | {LEFT|RIGHT} [OUTER] JOIN}table_referencesON conditional_expr连接类型INNER JOIN 内连接在MySQL中，JOIN,CROSS JOIN和INNER JOIN是等价的LEFT [OUTER] JOIN,左外连接RIGHT [OUTER] JOIN,右外连接内连接：显示左表与右表符合连接条件的记录外连接：显示左表的全部记录及右表符合连接条件的记录连接条件使用ON关键字来设定连接条件，也可以使用WHERE来代替通常使用ON关键字来设置连接条件使用WHERE关键字进行结果集记录的过滤多表连接SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM test_goods AS gINNER JOIN test_boods_cate AS c ON g.cate_id = c.cate_id,INNER JOIN test_goods_brands AS b ON g.brand_id = b.brand_id;外连接A LEFT JOIN B join_condition数据表B的结果集依赖数据表A数据表A的结果集根据左连接条件依赖所有数据表(B表除外)左外连接条件决定如何检索数据表B(在没有指定WHERE条件的情况下)如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接着条件的记录后停止搜索更多的行。例：无限级表分类一级分类 二级分类 三级分类 。。。自身连接同一个数据表对其自身进行连接例：在同一个表里面查出子类和父类SELECT s.type_id,s.type_name,p.type_name FROM tdb_goods_types AS s LEFT JOIN tdb_goods_types AS pON s.parent_id = p.type_id;-uroot -proot(MySQL自定义函数SELECT NOW();SELECT DATE_FORMAT(NOW(),’%Y年%m月%d日 %H时%i分%s秒’)MySQL支持的存储引擎存储引擎： MyISAMInnoDBMemoryCSVArchive相关知识点1.并发控制：当多个连接对记录进行修改时保证数据的一致性和完整性两个用户同时登录，其中一个用户删除id=22的记录，另外一个用户则要读取id=22的记录，发生的结果可能是正在读取的用户报错而退出，也有可能得到一条与实际记录不符的信息解决这类问题的经典方案是并发控制。锁：共享锁(读锁)：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化。排他锁(写锁)：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。锁颗粒：表锁，是一种开销最小的锁策略行锁，是一种开销最大的锁策略 支持最大并发事务：事务用于保证数据库的完整性用户A —-&gt; 转账200元 —-&gt; 用户B实现步骤：1.从A账户减掉200元（账户余额大于等于200）2.在B账号上增加200元事务的特性： 原子性(Atomicity)一致性(Consistency)隔离性(Isolation)持久性(Durability)外键：是保证数据一致性的策略索引：是对数据表中一列或多列的值进行排序的一种结构普通索引唯一索引全文索引btree索引hash索引…各种存储引擎的特点MyISAM:存储限制：256TB 事务安全：- 支持索引：支持 锁颗粒：表锁 数据压缩：支持 支持外键：-InnoDB:存储限制：64TB 事务安全：支持 支持索引：支持 锁颗粒：行锁 数据压缩：- 支持外键：支持Memory:存储限制：有 事务安全：- 支持索引：支持 锁颗粒：表锁 数据压缩：- 支持外键：-Archive:存储限制：无 事务安全：- 支持索引： 锁颗粒：行锁 数据压缩：支持 支持外键：-CSV:为每个表创建csv后缀文件应用的最多的存储引擎：MyISAM : 适用于事务处理不多的情况InnoDB : 适用于事务处理比校多，需要有外键支持的情况。设置存储引擎：1.通过修改MySQL配置文件实现default-storage-engine = engine_name//engine_name高版本默认是InnoDB;2.通过创建数据表命令实现CREATE TABLE table_name(…) ENGINE = engine_name;3.通过修改数据表命令实现ALTER TABLE table_name ENGINE [=] engine_name; MySQL管理工具：phpMyAdminNavicat]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>分享</tag>
        <tag>mysql</tag>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解(转载 Mr.Xia )]]></title>
    <url>%2F2018%2F12%2F11%2FpostName%2F</url>
    <content type="text"><![CDATA[引言 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体 信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。 目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中， 而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议的主要特点可概括如下： 1.支持客户/服务器模式。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。 请求方法常用的有GET、HEAD、POST。 每种方法规定了客户与服务器联系的类型不同。 由于HTTP协议简单，使得HTTP服务器的程序规模小，因而 通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求， 并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。 缺少状态意味着如果后续处理需要前面的信息，则它必须重传， 这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需 要先前信息时它的应答就较快。 一、HTTP协议详解之URL篇http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议， 常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发， 都是构建在HTTP协议之上的Web应用。 HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下： http://host[&quot;:&quot;port][abs_path] http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址； port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI； 如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出， 通常这个工作浏览器自动帮我们完成。 eg: 1、输入：www.guet.edu.cn 浏览器自动转换成：http://www.guet.edu.cn/ 2、http:192.168.0.116:8080/index.jsp 二、HTTP协议详解之请求篇http请求由三部分组成，分别是：请求行、消息报头、请求正文 1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本， 格式如下：Method Request-URI HTTP-Version CRLF，其中 Method表示请求方法；Request-URI是一个统一资源标识符； HTTP-Version表示请求的HTTP协议版本； CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法（所有方法全为大写）有多种，各个方法的解释如下： GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 应用举例： GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源， eg:GET /form.html HTTP/1.1 (CRLF) POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。 eg：POST /reg.jsp HTTP/ (CRLF) Accept:image/gif,image/x-xbit,... (CRLF) ... HOST:www.guet.edu.cn (CRLF) Content-Length:22 (CRLF) Connection:Keep-Alive (CRLF) Cache-Control:no-cache (CRLF) (CRLF) //该CRLF表示消息报头已经结束，在此之前为消息报头 user=jeffrey&amp;pwd=1234 //此行以下为提交的数据 HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与 通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI 所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 2、请求报头后述 3、请求正文(略) 三、HTTP协议详解之响应篇在接收和解释请求消息后，服务器返回一个HTTP响应消息。 HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 1、状态行格式如下： HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码； Reason-Phrase表示状态代码的文本描述。 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息--表示请求已接收，继续处理 2xx：成功--表示请求已被成功接收、理解、接受 3xx：重定向--要完成请求必须进行更进一步的操作 4xx：客户端错误--请求有语法错误或请求无法实现 5xx：服务器端错误--服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 eg：HTTP/1.1 200 OK （CRLF） 2、响应报头后述 3、响应正文就是服务器返回的资源的内容 四、HTTP协议详解之消息报头篇HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。 请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行， 对于响应消息，开始行就是状态行），消息报头（可选）， 空行（只有CRLF的行），消息正文（可选）组成。 HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。 每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 1、普通报头 在普通报头中，有少数报头域用于所有的请求和响应消息， 但并不用于被传输的实体，只用于传输的消息。 eg： Cache-Control 用于指定缓存指令，缓存指令是单向的 （响应中出现的缓存指令在请求中未必会出现），且是独立的 （一个消息的缓存指令不会影响另一个消息处理的缓存机制）， HTTP1.0使用的类似的报头域为Pragma。 请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、 no-store、max-age、max-stale、min-fresh、only-if-cached; 响应时的缓存指令包括：public、private、no-cache、no-store、no-transform 、must-revalidate、proxy-revalidate、max-age、s-maxage. eg： 为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下： response.sehHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); //response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);作用相当于上述代码， 通常两者//合用 这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache Date普通报头域表示消息产生的日期和时间 Connection普通报头域允许发送指定连接的选项。例如指定连接是连续， 或者指定“close”选项，通知服务器，在响应完成后，关闭连接 2、请求报头 请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 常用的请求报头 Accept Accept请求报头域用于指定客户端接受哪些类型的信息。 eg：Accept：image/gif， 表明客户端希望接受GIF图象格式的资源；Accept：text/html， 表明客户端希望接受html文本。 Accept-Charset Accept-Charset请求报头域用于指定客户端接受的字符集。 eg：Accept-Charset:iso-8859-1,gb2312. 如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Accept-Encoding Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。 eg： Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户 端对各种内容编码都可以接受。 Accept-Language Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。 eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域， 服务器假定客户端对各种语言都可以接受。 Authorization Authorization请求报头域主要用于证明客户端有权查看某个资源。 当浏览器访问一个页面时， 如果收到服务器的响应代码为401（未授权）， 可以发送一个包含Authorization请求报头域的请求， 要求服务器对其进行验证。 Host（发送请求时，该报头域是必需的） Host请求报头域主要用于指定被请求资源的Internet主机和端口号， 它通常从HTTP URL中提取出来的， eg： 我们在浏览器中输入：http://www.guet.edu.cn/index.html 浏览器发送的请求消息中，就会包含Host请求报头域，如下： Host：www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号， 则变成：Host：www.guet.edu.cn:指定端口号 User-Agent 我们上网登陆论坛的时候，往往会看到一些欢迎信息， 其中列出了你的操作系统的名称和版本， 你所使用的浏览器的名称和版本，这往往让很多人感到很神奇， 实际上，服务器应用程序就是 从User-Agent这个请求报头域中获取到这些信息。 User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 不过，这个报头域不是必需的，如果我们自己编写一个浏览器， 不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。 请求报头举例： GET /form.html HTTP/1.1 (CRLF) Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash, application/vnd.ms-excel, application/vnd.ms-powerpoint,application/msword,/ (CRLF) Accept-Language:zh-cn (CRLF) Accept-Encoding:gzip,deflate (CRLF) If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF) If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF) User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF) Host:www.guet.edu.cn (CRLF) Connection:Keep-Alive (CRLF) (CRLF) 3、响应报头 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及 关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头 Location Location响应报头域用于重定向接受者到一个新的位置。 Location响应报头域常用在更换域名的时候。 Server Server响应报头域包含了服务器用来处理请求的软件信息。 与User-Agent请求报头域是相对应的。 下面是Server响应报头域的一个例子： Server：Apache-Coyote/1.1 WWW-Authenticate WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中， 客户端收到401响应消息时候， 并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头 就包含该报头域。 eg：WWW-Authenticate:Basic realm=&quot;Basic Auth Test!&quot; //可以看出服务器对请求资源采用的是基本验证机制。 4、实体报头 请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成， 但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。 实体报头定义了关于实体正文（eg：有无实体正文）和 请求所标识的资源的元信息。 常用的实体报头 Content-Encoding Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应 用到实体正文的附加内容的编码， 因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。 Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip Content-Language Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体 内容将提供给所有的语言阅读者。eg：Content-Language:da Content-Length Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字 来表示。 Content-Type Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg： Content-Type:text/html;charset=ISO-8859-1 Content-Type:text/html;charset=GB2312 Last-Modified Last-Modified实体报头域用于指示资源的最后修改日期和时间。 Expires Expires实体报头域给出响应过期的日期和时间。 为了让代理服务器或浏览器在一段时间以后更新缓存中 (再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载) 的页面，我们可以使用Expires实体报头域指定页面过期的时间。 eg：Expires：Thu，15 Sep 2006 16:23:12 GMT HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。 eg：为了让浏览器不要缓存页面， 我们也可以利用Expires实体报头域，设置为0， jsp中程序如下：response.setDateHeader(&quot;Expires&quot;,&quot;0&quot;); 五、利用telnet观察http协议的通讯过程 实验目的及原理： 利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求， 服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口 上显示出来，从而从感性上加深对http协议的通讯过程的认识。 实验步骤： 1、打开telnet 1.1 打开telnet 运行--&gt;cmd--&gt;telnet 1.2 打开telnet回显功能 set localecho 2、连接服务器并发送请求 2.1 open www.guet.edu.cn 80 //注意端口号不能省略 HEAD /index.asp HTTP/1.0 Host:www.guet.edu.cn /我们可以变换请求方法,请求桂林电子主页内容,输入消息如下/ open www.guet.edu.cn 80 GET /index.asp HTTP/1.0 //请求资源的内容 Host:www.guet.edu.cn 2.2 open www.sina.com.cn 80 //在命令提示符号下直接输入 telnet www.sina.com.cn 80 HEAD /index.asp HTTP/1.0 Host:www.sina.com.cn 3 实验结果： 3.1 请求信息2.1得到的响应是: HTTP/1.1 200 OK //请求成功 Server: Microsoft-IIS/5.0 //web服务器 Date: Thu,08 Mar 200707:17:51 GMT Connection: Keep-Alive Content-Length: 23330 Content-Type: text/html Expries: Thu,08 Mar 2007 07:16:51 GMT Set-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/ Cache-control: private //资源内容省略 3.2 请求信息2.2得到的响应是: HTTP/1.0 404 Not Found //请求失败 Date: Thu, 08 Mar 2007 07:50:50 GMT Server: Apache/2.0.54 Last-Modified: Thu, 30 Nov 2006 11:35:41 GMT ETag: &quot;6277a-415-e7c76980&quot; Accept-Ranges: bytes X-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remix Vary: Accept-Encoding Content-Type: text/html X-Cache: MISS from zjm152-78.sina.com.cn Via: 1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt; X-Cache: MISS from th-143.sina.com.cn Connection: close 失去了跟主机的连接 按任意键继续... 4 .注意事项： 1、出现输入错误，则请求不会成功。 2、报头域不分大小写。 3、更深一步了解HTTP协议，可以查看RFC2616，在http://www.letf.org/rfc上 找到该文件。 4、开发后台程序必须掌握http协议 六、HTTP协议相关技术补充 1、基础： 高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、 网络新闻传输协议NNTP和HTTP协议等 中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)， 一个代理根据URI的绝对格式来接受请求， 重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。 网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话， 可以把请求翻译给下层的服务器协议。 一 个通道作为不改变消息的两个连接之间的中继点。 当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时， 通道经常被使用。 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机， 为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。 一个代理在发送请求信息之前,必须解释并且如果可能重写它。 代理经常作为通过防火墙的客户机端的门户， 代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。 网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是， 网关接受请求就好象对被请求的资源来说它就是源服务器； 发出请求的客户机并没有意识到它在同网关打交道。 网关经常作为通过防火墙的服务器端的门户， 网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活， 通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。 当被中继 的连接两端关闭时，通道便消失。 当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时 通道被经常使用。 2、协议分析的优势—HTTP分析器检测网络攻击 以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。 HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定 3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击 使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度， 例如ContentLenth:999999999， 在传送完成前，内 存不会释放，攻击者可以利用这个缺陷， 连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。 这种攻击方法基本不会留下痕迹。 http://www.cnpaf.net/Class/HTTP/0532918532667330.html 4、利用HTTP协议的特性进行拒绝服务攻击的一些构思 服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求 （毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来， 服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。 而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。 本文用“正常连接”的方法来产生拒绝服务攻击。 19端口在早期已经有人用来做Chargen攻击了， 即Chargen_Denial_of_Service，但是！ 他们用的方法是在两台Chargen 服务器之间产生UDP连接， 让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个： 1.有Chargen服务 2.有HTTP 服务 方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect）， Chargen接收到连接后就会返回每秒72字节的字符流实际上根据网络实际情况， 这个速度更快）给服务器。 5、Http指纹识别技术 Http指纹识别的原理大致上也是相同的： 记录不同服务器对Http协议执行中的微小差别进行识别. Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、 增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难； 然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别. 要让服务器返回不同的Banner信息的设置是很简单的, 象Apache这样的开放源代码的Http服务器,用户可以在 源代码里修改Banner信息,然后重起Http服务就生效了； 对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape, 可以在存放Banner信息的Dll文件中修改, 相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的. 另外一种模糊Banner信息的方法是使用插件。 常用测试请求： 1：HEAD/Http/1.0发送基本的Http请求 2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求 3：GET/Http/3.0发送一个非法版本的Http协议请求 4：GET/JUNK/1.0发送一个不正确规格的Http协议请求 Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术, 能很有效的确定Http服务器的类型. 它可以被用来收集和分析不同Http服务器产生的签名。 6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式， 浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标， 这样能更快速完成整个网页的传输。HTTP1.1中提供了这种持续连接的方式， 而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持， 来提供更高效率的连接。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>分享</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
